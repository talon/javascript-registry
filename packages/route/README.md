# @talon/route

> encode/decode data to/from routes

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### Table of Contents

- - [keys][1]
    - [Parameters][2]
  - [values][3]
    - [Parameters][4]
  - [encode][5]
    - [Parameters][6]
  - [decode][7]
    - [Parameters][8]
  - [withBody][9]
    - [Parameters][10]
  - [withConstant][11]
    - [Parameters][12]
- [Future][13]

## keys

```js
import * as Route from "./lib"

test("Route.keys", () => {
  expect(Route.keys("/routes/are/made/of/:keys")).toEqual([
    "routes",
    "are",
    "made",
    "of",
    "keys"
  ])
})
```

### Parameters

- `route` **[string][14]**

Returns **[Array][15]&lt;[string][14]>**

## values

```js
test("Route.values", () => {
  expect(Route.values("/pathnames/are/made/of/values")).toEqual([
    "pathnames",
    "are",
    "made",
    "of",
    "values"
  ])
})
```

### Parameters

- `pathname` **[string][14]**

Returns **[Array][15]&lt;[string][14]>**

## encode

encode an object into a route

### Parameters

- `route` **[string][14]**
- `data` **any**

Returns **[string][14]**

## decode

decode an object from a route

### Parameters

- `route` **[string][14]**
- `url` **[string][14]**

Returns **any**

## withBody

For requests other than GET it's usually more useful to return the pathname `withBody` so the rest of the object can
be sent in the request.

```js
test("Route.withBody", () => {
  const [pathname, body] = Route.withBody("/:id/people/:name", {
    id: 1,
    name: "belle",
    limit: 1
  })

  expect(pathname).toBe("/1/people/belle")
  expect(body).toEqual({ limit: 1 })
})
```

### Parameters

- `route` **[string][14]**
- `data` **any**

Returns **\[[string][14], any]**

## withConstant

By default only the dynamic keys are decoded. To also include the constant keys use `Route.withConstants`

```js
test.skip("Route.withConstants", () => {
  expect(
    Route.withConstants("/:id/people/:name", "/1/people/belle", {
      id: 1,
      name: "belle",
      limit: 1
    })
  ).toEqual({
    id: 1,
    people: "people",
    name: "belle",
    limit: 1
  })
})
```

### Parameters

- `route` **[string][14]**
- `url` **[string][14]**

Returns **any**

##

# Future

Maybe you wanna see if this route is the same as another

```js
test.skip("Route.matches", () => {
  expect(
    Route.matches(
      "/pathnames/are/made/of/:keys",
      "/pathnames/are/made/of/:keys"
    )
  ).toBeTruthy()

  expect(
    Route.matches("/pathnames/are/made/of/:keys", "/pathnames/made/of/:keys")
  ).toBeFalsey()
})
```

or check if the route fits a pathname

```js
test.skip("Route.fits", () => {
  expect(
    Route.fits(
      "/pathnames/:are/made/of/:keys",
      "/pathnames/dogs/made/of/things"
    )
  ).toBeTruthy()

  expect(
    Route.fits("/pathnames/are/made/of/:keys", "/pathnames/made/of/things")
  ).toBeFalsey()
})
```

**Experimental:** a sugar kinda way to deal with all this

```js
test.skip("Route.create", () => {
  const route = Route.create("/another/:adjective/route")

  expect(route.decode("/another/cool/route")).toEqual({ adjective: "cool" })
  expect(route.encode({ adjective: "fun" })).toBe("/another/fun/route")
  expect(route.matches("/another/:adjective/route")).toBeTruthy()
  expect(route.fits("/another/sick/route")).toBeTruthy()
  expect(route.keys).toEqual(["another", "adjective", "route"])
  expect(route.values).toEqual(["another", undefined, "route"])
})
```

[1]: #keys
[2]: #parameters
[3]: #values
[4]: #parameters-1
[5]: #encode
[6]: #parameters-2
[7]: #decode
[8]: #parameters-3
[9]: #withbody
[10]: #parameters-4
[11]: #withconstant
[12]: #parameters-5
[13]: #future
[14]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String
[15]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array
