<!-- Generated by @talon/sip. Update this documentation by updating the source code. -->
# @talon/sip
>ðŸ¥¤ gulp tasks for great good

**Table of Contents**

<!-- toc -->

- [dependencies](#dependencies)
- [docs](#docs)
- [test](#test)
- [develop](#develop)
- [format](#format)
- [compile](#compile)
- [build](#build)
- [tasks](#tasks)
- [Monorepo](#monorepo)
- [init](#init)

<!-- tocstop -->

## dependencies

Automatically update dependencies adding and removing as needed

### Parameters

-   `pkg` **[string][1]** the path to the package to operate on

Returns **TaskFunction** the initialized gulp task

## docs

Create a README.md for this package by parsing the source code for JSDoc style comments

**You should never edit the README**, only lib code. Namaste ðŸ•Š

### Parameters

-   `pkg` **[string][1]** the path to the package to operate on

Returns **TaskFunction** the initialized gulp task

## test

With [@talon/lit][2] **you can test your README!**

just add a js code block in your JSDoc comments ðŸ˜Ž

```js
describe("readme driven development", () => {
  it("is lit! ðŸ”¥", () => expect(true).toBeTruthy())
})
```

### Parameters

-   `pkg` **[string][1]** the path to the package to operate on

Returns **TaskFunction** the initialized gulp task

## develop

You probably want the docs and tests to update while you're in the thick of it

### Parameters

-   `pkg` **[string][1]** the path to the package to operate on

Returns **TaskFunction** the initialized gulp task

## format

Run prettier on everything, don't think about style

### Parameters

-   `pkg` **[string][1]** the path to the package to operate on

Returns **TaskFunction** the initialized gulp task

## compile

Babel it all up and stuff it into a distribution folder

### Parameters

-   `pkg` **[string][1]** the path to the package to operate on

Returns **TaskFunction** the initialized gulp task

## build

All of this together into one task, excellent for CI environments!

A bunch of sips === a gulp

### Parameters

-   `pkg` **[string][1]** the path to the package to operate on

Returns **TaskFunction** the initialized gulp task

## tasks

This initializes the Sip Suite with a package root. With Lerna you can use it like this

    Object.assign(exports, Sip.tasks(process.env.LERNA_PACKAGE_NAME ? `${__dirname}/packages/${process.env.LERNA_PACKAGE_NAME.split("/").slice(-1)}` : false))

or for non-monorepo projects like this

    Object.assign(exports, Sip.tasks(__dirname))

### Parameters

-   `pkg` **[string][1]** the path to the package to operate on

Returns **[object][3]** initalized gulp tasks

## Monorepo

Type: [Object][3]

### Properties

-   `repository` **[string][1]** the URL for this repo
-   `directory` **[string][1]** the directory with your packages
-   `registry` **[string][1]** the registry link where you publish your packages
-   `scope` **[string][1]** your npm scope

## init

You will be prompted for a few answers and then your package will be made available under your packages folder!

Here's how to initialize this in your root monorepo gulpfile

    exports.init = Mono.init({
        repository: meta.repository.url,
        directory: meta.workspaces[0],
        registry: "https://npm.pkg.github.com",
        scope: "talon"
    })

### Parameters

-   `repo` **[Monorepo][4]** for the mono repo

Returns **[function][5]** the initalized gulp task

[1]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String

[2]: https://github.com/talon/javascript-registry/packages/92916

[3]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object

[4]: #monorepo

[5]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function
