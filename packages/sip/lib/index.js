//@flow
import { src, dest, series, watch } from "gulp"
import documentation from "gulp-documentation"
import modify from "gulp-modify-file"
import prettier from "gulp-prettier"
import toc from "markdown-toc"
import babel from "gulp-babel"
import jest from "gulp-jest"
import inquirer from "inquirer"
import fs from "fs"
import { resolve } from "path"

const { stat, mkdir, writeFile } = fs.promises

/*:: 
type Package = {
  repository: string,
  directory: string,
  registry: string,
  scope: string
} 
*/

/**
 * Create a new package
 */
export const init = (pkg /*: Package */) => () => {
  console.log("🥚  Oh! A package!")
  return inquirer
    .prompt([
      {
        type: 'input',
        name: 'name',
        message: "🥚  What do you call it?",
      },
      {
        type: 'input',
        name: 'description',
        message: "🥚  What does it do?",
      },
      {
        type: 'input',
        name: 'author',
        message: "🥚  Who is the author?",
      },
      {
        type: 'input',
        name: 'keywords',
        message: "🥚  What are some keywords for it?"
      }
    ])
    .then(prompt => Object.assign(prompt, {
      name: `@${pkg.scope}/${prompt.name}`,
      repository: {
        type: "git",
        url: pkg.repository,
        directory: `${pkg.directory}/${prompt.name}`
      },
      keywords: prompt.keywords.split(",").map(keyword => keyword.trim()),
      main: "dist",
      files: [
        "lib",
        "dist"
      ]
    })).then(meta => {
      const dir = resolve(meta.repository.directory)
      return stat(dir)
        .then(stat => {
          throw new Error(`Oh no. ${meta.name} already exists! (${dir})`)
        })
        .catch(e => { })
        .then(() => mkdir(dir))
        .then(() => writeFile(`${dir}/package.json`, JSON.stringify(meta, null, 2), "utf8"))
        .then(() => mkdir(`${dir}/lib`))
        .then(() => console.log(`🐣  ${meta.name} has been created!`))
    })
}

/**
 * Create a README.md for this package by parsing the source code for JSDoc style comments
 *
 * **You should never edit the README**, only lib code. Namaste 🕊
 */
export const docs = (pkg /*: string */) => () => {
  const meta = require(`${pkg}/package.json`)

  return src(`${pkg}/lib/**`)
    .pipe(documentation("md", { filename: "README.md" }))
    .pipe(
      modify(
        content =>
          `<!-- Generated by @talon/sip. Update this documentation by updating the source code. -->\n# ${`[${meta.name}](${meta.homepage})`}\n>${
          meta.description
          }\n\n**Table of Contents**\n<!-- toc -->\n${content.substring(
            content.indexOf("\n") + 2
          )}`
      )
    )
    .pipe(modify(content => toc.insert(content, { maxdepth: 2 })))
    .pipe(prettier())
    .pipe(dest(pkg), { overwrite: true })
}
/**
 * With [@talon/lit](https://github.com/talon/javascript-registry/packages/92916) **you can test your README!**
 *
 * just add a js code block in your JSDoc comments 😎
 *
 * ```js
 * describe("readme driven development", () => {
 *   it("is lit! 🔥", () => expect(true).toBeTruthy())
 * })
 * ```
 */
export const test = (pkg /*: string */) =>
  series(docs(pkg), () => {
    process.env.NODE_ENV = "test"
    return src(`${pkg}`).pipe(
      jest({
        testRegex: new RegExp(
          `${pkg}\/(README.md|.+\.(usage|test)\.([jt]sx?|md))`
        )
      })
    )
  })

/**
 * You probably want the docs and tests to update while you're in the thick of it
 */
export const develop = (pkg /*: string */) =>
  series(test(pkg), () => watch(pkg, test(pkg)))

/**
 * Run prettier on everything, don't think about style
 */
export const format = (pkg /*: string */) => () =>
  src([`${pkg}/**`, `!${pkg}/node_modules/**`])
    .pipe(prettier())
    .pipe(dest(pkg))

/**
 * Babel it all up and stuff it into a distribution folder
 */
export const compile = (pkg /*: string */) => () =>
  src(`${pkg}/lib/**`)
    .pipe(babel())
    .pipe(dest(dir, { overwrite: true }))

/**
 * All of this together into one task, excellent for CI environments!
 *
 * A bunch of sips === a gulp
 */
export const build = (pkg /*: string */) =>
  series(test(pkg), format(pkg), compile(pkg))
