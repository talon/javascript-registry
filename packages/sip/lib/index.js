// @flow
import { src, dest, series, watch, TaskFunction } from "gulp"
import documentation from "gulp-documentation"
import modify from "gulp-modify-file"
import lint from "gulp-eslint"
import toc from "markdown-toc"
import babel from "gulp-babel"
import jest from "gulp-jest"
import typescript from "gulp-typescript"
import check from "depcheck"
// $FlowFixMe
import { promisify } from "util"
import { exec } from "child_process"

/**
 * Automatically update dependencies adding and removing as needed
 *
 * @param {string} pkg the path to the package to operate on
 * @returns {TaskFunction} the initialized gulp task
 */
export function dependencies(pkg) {
  const name = pkg.split("/").slice(-1)

  return function install() {
    return check(pkg, {
      ignoreDirs: ["dist"]
    })
      .then(data => {
        const missing = Object.keys(data.missing)
        return missing.length > 0
          ? promisify(exec)(
              `yarn workspace @talon/${name} add ${Object.keys(
                data.missing
              ).join(" ")}`
            ).then(() => data)
          : data
      })
      .then(data => {
        const unused = data.dependencies.concat(data.devDependencies)
        return unused.length > 0
          ? promisify(exec)(
              `yarn workspace @talon/${name} remove ${unused.join(" ")}`
            ).then(() => data)
          : data
      })
  }
}

/**
 * Create a README.md for this package by parsing the source code for JSDoc style comments
 *
 * **You should never edit the README**, only lib code. Namaste ðŸ•Š
 *
 * @param {string} pkg the path to the package to operate on
 * @returns {TaskFunction} the initialized gulp task
 */
export function docs(pkg) {
  return function README() {
    const meta = require(`${pkg}/package.json`)

    return src(`${pkg}/lib/**`)
      .pipe(lint({ fix: true }))
      .pipe(lint.format())
      .pipe(lint.failAfterError())
      .pipe(
        typescript({
          esModuleInterop: true,
          allowJs: true,
          checkJs: true
        })
      )
      .pipe(documentation("md", { filename: "README.md" }, null))
      .pipe(
        modify(
          content =>
            `<!-- Generated by @talon/sip. Update this documentation by updating the source code. -->\n# ${
              meta.name
            }\n>${
              meta.description
            }\n\n**Table of Contents**\n<!-- toc -->\n${content.substring(
              content.indexOf("\n") + 2
            )}`
        )
      )
      .pipe(modify(content => toc.insert(content, { maxdepth: 2 })))
      .pipe(dest(pkg), { overwrite: true })
  }
}

/**
 * With [@talon/lit](https://github.com/talon/javascript-registry/packages/92916) **you can test your README!**
 *
 * just add a js code block in your JSDoc comments ðŸ˜Ž
 *
 * ```js
 * describe("readme driven development", () => {
 *   it("is lit! ðŸ”¥", () => expect(true).toBeTruthy())
 * })
 * ```
 *
 * @param {string} pkg the path to the package to operate on
 * @returns {TaskFunction} the initialized gulp task
 */
export function test(pkg) {
  return series(dependencies(pkg), docs(pkg), function tests() {
    process.env.NODE_ENV = "test"
    return src(`${pkg}`).pipe(
      jest({
        testRegex: new RegExp(
          `${pkg}\/(README.md|.+\.(usage|test)\.([jt]sx?|md))`
        )
      })
    )
  })
}

/**
 * You probably want the docs and tests to update while you're in the thick of it
 *
 * @param {string} pkg the path to the package to operate on
 * @returns {TaskFunction} the initialized gulp task
 */
export const develop = pkg =>
  series(test(pkg), function watchPkg() {
    watch(`${pkg}/lib/**`, test(pkg))
  })

/**
 * Run prettier on everything, don't think about style
 *
 * @param {string} pkg the path to the package to operate on
 * @returns {TaskFunction} the initialized gulp task
 */
export const format = pkg =>
  function formatFiles() {
    return src([`${pkg}/**`, `!${pkg}/node_modules/**`])
      .pipe(lint({ fix: true }))
      .pipe(dest(pkg))
  }

/**
 * Babel it all up and stuff it into a distribution folder
 *
 * @param {string} pkg the path to the package to operate on
 * @returns {TaskFunction} the initialized gulp task
 */
export const compile = pkg =>
  function compileLib() {
    return src(`${pkg}/lib/**`)
      .pipe(babel())
      .pipe(dest(`${pkg}/dist`, { overwrite: true }))
  }

/**
 * All of this together into one task, excellent for CI environments!
 *
 * A bunch of sips === a gulp
 *
 * @param {string} pkg the path to the package to operate on
 * @returns {TaskFunction} the initialized gulp task
 */
export const build = pkg => series(test(pkg), format(pkg), compile(pkg))

/**
 * This initializes the Sip Suite with a package root. With Lerna you can use it like this
 *
 * ```
 * Object.assign(exports, Sip.tasks(process.env.LERNA_PACKAGE_NAME ? `${__dirname}/packages/${process.env.LERNA_PACKAGE_NAME.split("/").slice(-1)}` : false))
 * ```
 *
 * or for non-monorepo projects like this
 *
 * ```
 * Object.assign(exports, Sip.tasks(__dirname))
 * ```
 *
 * @param {string} pkg the path to the package to operate on
 * @returns {object} initalized gulp tasks
 */
export const tasks = pkg =>
  pkg
    ? {
        dependencies: dependencies(pkg),
        docs: docs(pkg),
        format: format(pkg),
        test: test(pkg),
        compile: compile(pkg),
        build: build(pkg),
        develop: develop(pkg)
      }
    : {}
